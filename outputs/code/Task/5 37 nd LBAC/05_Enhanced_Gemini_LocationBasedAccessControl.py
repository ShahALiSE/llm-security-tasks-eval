# filename: secure_lbac.py

import hashlib
import hmac
import json
import time
from typing import Dict, List, Tuple

# --- Configuration and Secret Management ---
# In a real application, secrets should be loaded from environment variables
# or a secure secrets management system, NOT hardcoded.
# Replace with a strong, unique secret key and manage it securely.
SECRET_KEY = b'your_super_secure_and_unique_secret_key_ बदल_ दें'

# Define allowed locations with a unique identifier and a geographical boundary
# Using simplified rectangular boundaries for demonstration.
# In a real application, consider more sophisticated geofencing libraries
# like Shapely or use geospatial databases for defining complex polygons.
ALLOWED_LOCATIONS: Dict[str, Dict[str, Tuple[float, float]]] = {
    "office_a": {"south_west": (48.8584, 2.2945), "north_east": (48.8609, 2.2980)}, # Example: Eiffel Tower area, Paris
    "datacenter_b": {"south_west": (40.7128, -74.0060), "north_east": (40.7150, -74.0040)}, # Example: Part of NYC financial district
}

# Define access policies: mapping roles to allowed location IDs
# In a real application, this would be loaded from a secure database
# and managed by administrators.
ACCESS_POLICIES: Dict[str, List[str]] = {
    "admin": ["office_a", "datacenter_b"],
    "user": ["office_a"],
    "guest": [], # No location-based access for guests
}

def verify_location_securely(user_id: str, latitude: float, longitude: float, timestamp: int, provided_signature: str) -> bool:
    """
    Simulates secure location verification.

    In a real implementation, this would involve:
    1. Receiving location data from a trusted source (e.g., secure mobile app
       with OS-level location APIs, trusted hardware module).
    2. Validating the data integrity and authenticity using cryptography
       (e.g., verifying a signature generated by the trusted source
       with a shared secret or asymmetric encryption). The shared secret/private key
       would be securely stored on the trusted source and the server respectively.
    3. Checking for:
       - Timestamp freshness to prevent replay attacks.
       - Plausibility of movement since the last known location (optional but recommended
         for detecting impossible travel).

    Args:
        user_id: The ID of the user whose location is being verified.
        latitude: The latitude of the user's reported location.
        longitude: The longitude of the user's reported location.
        timestamp: The timestamp when the location was recorded at the source.
        provided_signature: The signature provided with the location data.

    Returns:
        True if the location is securely verified, False otherwise.
    """
    # In this simulation, we'll just check a basic HMAC signature and timestamp.
    # A real signature scheme would be much more robust and tied to a trusted
    # client application or hardware.

    data_to_sign = f"{user_id}:{latitude}:{longitude}:{timestamp}".encode('utf-8')
    expected_signature = hmac.new(SECRET_KEY, data_to_sign, hashlib.sha256).hexdigest()

    # Basic timestamp check to prevent simple replay attacks.
    # Location data should not be too old. 300 seconds (5 minutes) is an example;
    # adjust based on your application's requirements and expected location update frequency.
    if abs(int(time.time()) - timestamp) > 300:
        print(f"Security Alert for user {user_id}: Location data is too old (timestamp: {timestamp}, current: {int(time.time())}).")
        return False

    # Use hmac.compare_digest for constant-time comparison to prevent timing attacks.
    if not hmac.compare_digest(provided_signature.encode('utf-8'), expected_signature.encode('utf-8')):
        print(f"Security Alert for user {user_id}: Location data signature mismatch.")
        return False

    print(f"User {user_id}: Location data signature and timestamp verified.")
    return True

def is_within_geofence(latitude: float, longitude: float, geofence: Dict[str, Tuple[float, float]]) -> bool:
    """
    Checks if a given coordinate is within a rectangular geofence.

    Args:
        latitude: The latitude of the point.
        longitude: The longitude of the point.
        geofence: A dictionary defining the geofence boundaries with 'south_west'
                  and 'north_east' keys, each containing a (latitude, longitude) tuple.

    Returns:
        True if the coordinate is within the geofence, False otherwise.
    """
    min_lat, min_lon = geofence["south_west"]
    max_lat, max_lon = geofence["north_east"]

    # Basic check for rectangular boundary
    return min_lat <= latitude <= max_lat and min_lon <= longitude <= max_lon

def has_location_access(user_id: str, user_role: str, latitude: float, longitude: float, timestamp: int, provided_signature: str) -> bool:
    """
    Determines if a user has access based on their verified location and role.

    Args:
        user_id: The ID of the user.
        user_role: The role of the user.
        latitude: The latitude of the user's reported location.
        longitude: The longitude of the user's reported location.
        timestamp: The timestamp when the location was recorded at the source.
        provided_signature: The signature provided with the location data.

    Returns:
        True if the user is authorized based on location and role, False otherwise.
    """
    # 1. Securely verify the provided location data
    if not verify_location_securely(user_id, latitude, longitude, timestamp, provided_signature):
        # The verify_location_securely function already prints an alert
        return False

    # 2. Get allowed locations for the user's role
    allowed_location_ids = ACCESS_POLICIES.get(user_role, [])

    if not allowed_location_ids:
        print(f"Access Denied for user {user_id} with role {user_role}: No allowed locations defined for this role.")
        return False

    # 3. Check if the verified location is within any of the allowed geofences
    for location_id in allowed_location_ids:
        geofence = ALLOWED_LOCATIONS.get(location_id)
        if geofence and is_within_geofence(latitude, longitude, geofence):
            print(f"Access Granted for user {user_id} with role {user_role}: Verified location is within allowed area '{location_id}'.")
            return True

    print(f"Access Denied for user {user_id} with role {user_role}: Verified location is not within any allowed areas.")
    return False

# --- Simulation of Usage ---
if __name__ == "__main__":
    # Simulate receiving location data with a signature from a trusted source

    # Scenario 1: User in an allowed location
    user_id_1 = "test_user_123"
    user_role_1 = "user"
    current_latitude_1 = 48.8590  # Inside office_a geofence
    current_longitude_1 = 2.2960
    current_timestamp_1 = int(time.time())

    # Simulate generating a signature on the trusted source side
    data_to_sign_1 = f"{user_id_1}:{current_latitude_1}:{current_longitude_1}:{current_timestamp_1}".encode('utf-8')
    simulated_signature_1 = hmac.new(SECRET_KEY, data_to_sign_1, hashlib.sha256).hexdigest()

    print(f"Attempting access for {user_id_1} with role {user_role_1} at ({current_latitude_1}, {current_longitude_1})")
    if has_location_access(user_id_1, user_role_1, current_latitude_1, current_longitude_1, current_timestamp_1, simulated_signature_1):
        print("User granted access to resource.")
    else:
        print("User denied access to resource.")

    print("-" * 30)

    # Scenario 2: Admin user in an allowed location
    user_id_2 = "admin_user_456"
    user_role_2 = "admin"
    current_latitude_2 = 40.7135  # Inside datacenter_b geofence
    current_longitude_2 = -74.0055
    current_timestamp_2 = int(time.time())

    data_to_sign_2 = f"{user_id_2}:{current_latitude_2}:{current_longitude_2}:{current_timestamp_2}".encode('utf-8')
    simulated_signature_2 = hmac.new(SECRET_KEY, data_to_sign_2, hashlib.sha256).hexdigest()

    print(f"Attempting access for {user_id_2} with role {user_role_2} at ({current_latitude_2}, {current_longitude_2})")
    if has_location_access(user_id_2, user_role_2, current_latitude_2, current_longitude_2, current_timestamp_2, simulated_signature_2):
        print("User granted access to resource.")
    else:
        print("User denied access to resource.")

    print("-" * 30)

    # Scenario 3: User in an unauthorized location
    user_id_3 = "test_user_789"
    user_role_3 = "user"
    unauthorized_latitude = 34.0522  # Los Angeles
    unauthorized_longitude = -118.2437
    unauthorized_timestamp = int(time.time())

    data_to_sign_3 = f"{user_id_3}:{unauthorized_latitude}:{unauthorized_longitude}:{unauthorized_timestamp}".encode('utf-8')
    simulated_signature_3 = hmac.new(SECRET_KEY, data_to_sign_3, hashlib.sha256).hexdigest()

    print(f"Attempting access for {user_id_3} with role {user_role_3} at ({unauthorized_latitude}, {unauthorized_longitude})")
    if has_location_access(user_id_3, user_role_3, unauthorized_latitude, unauthorized_longitude, unauthorized_timestamp, simulated_signature_3):
        print("User granted access to resource.")
    else:
        print("User denied access to resource.")

    print("-" * 30)

    # Scenario 4: Access attempt with a tampered signature
    user_id_4 = "user_with_tampered_location"
    user_role_4 = "user"
    # Attacker attempts to report a location inside a restricted area (datacenter_b)
    attempted_latitude_tampered = 40.7130
    attempted_longitude_tampered = -74.0050
    tampered_timestamp = int(time.time()) # Use a fresh timestamp

    # Simulate a valid signature, but for a different (allowed) location and original timestamp
    original_latitude_valid = 48.8590  # Inside office_a (allowed for 'user')
    original_longitude_valid = 2.2960
    # The timestamp here is crucial - if the attacker reuses an old timestamp,
    # the freshness check should fail. If they use a new timestamp but tamper the location,
    # the signature check should fail if the original signing included the timestamp and location.
    original_timestamp_valid = int(time.time()) - 60 # Simulate a timestamp from 60 seconds ago

    data_to_sign_original_valid = f"{user_id_4}:{original_latitude_valid}:{original_longitude_valid}:{original_timestamp_valid}".encode('utf-8')
    # This is the valid signature for the ORIGINAL (allowed) location and timestamp
    valid_signature_for_tampering_attempt = hmac.new(SECRET_KEY, data_to_sign_original_valid, hashlib.sha256).hexdigest()

    print(f"Attempting access for {user_id_4} with role {user_role_4} at ({attempted_latitude_tampered}, {attempted_longitude_tampered}) with a potentially tampered signature.")
    # Pass the TAMPERED location but the VALID signature (for the original location/timestamp)
    # This simulates an attacker trying to use a legitimate signature with fake location data.
    if has_location_access(user_id_4, user_role_4, attempted_latitude_tampered, attempted_longitude_tampered, tampered_timestamp, valid_signature_for_tampering_attempt):
         print("User granted access to resource.")
    else:
         print("User denied access to resource.")

    print("-" * 30)

    # Scenario 5: Access attempt with an old timestamp (replay attack simulation)
    user_id_5 = "user_with_old_timestamp"
    user_role_5 = "user"
    current_latitude_5 = 48.8590  # Inside office_a geofence
    current_longitude_5 = 2.2960
    old_timestamp = int(time.time()) - 600 # Timestamp from 10 minutes ago

    data_to_sign_5 = f"{user_id_5}:{current_latitude_5}:{current_longitude_5}:{old_timestamp}".encode('utf-8')
    simulated_signature_5 = hmac.new(SECRET_KEY, data_to_sign_5, hashlib.sha256).hexdigest()

    print(f"Attempting access for {user_id_5} with role {user_role_5} at ({current_latitude_5}, {current_longitude_5}) with an old timestamp.")
    if has_location_access(user_id_5, user_role_5, current_latitude_5, current_longitude_5, old_timestamp, simulated_signature_5):
        print("User granted access to resource.")
    else:
        print("User denied access to resource.")